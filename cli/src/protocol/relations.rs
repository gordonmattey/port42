use serde::{Deserialize, Serialize};
use anyhow::Result;
use std::collections::HashMap;
use std::time::SystemTime;

use crate::protocol::{DaemonRequest, RequestBuilder, ResponseParser};
use crate::display::{Displayable, OutputFormat};
use colored::*;

// Relation represents a declarative entity that should exist
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Relation {
    pub id: String,
    #[serde(rename = "type")]
    pub relation_type: String, // "Tool", "Artifact", "Memory"
    pub properties: HashMap<String, serde_json::Value>,
    pub created_at: Option<SystemTime>,
    pub updated_at: Option<SystemTime>,
}

// Reference represents a contextual reference to enhance tool generation
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Reference {
    #[serde(rename = "type")]
    pub ref_type: String,
    pub target: String,
    pub context: Option<String>,
}

// Request to declare a new relation
#[derive(Debug, Serialize)]
pub struct DeclareRelationRequest {
    pub relation: Relation,
    pub references: Option<Vec<Reference>>,
    pub user_prompt: Option<String>,
}

// Response from declaring a relation
#[derive(Debug, Serialize, Deserialize)]
pub struct DeclareRelationResponse {
    pub relation_id: String,
    #[serde(rename = "type")]
    pub relation_type: String,
    pub materialized: bool,
    pub physical_path: String,
    pub status: String,
}


// Helper to create a tool relation
impl Relation {
    pub fn new_tool(name: &str, transforms: Vec<String>) -> Self {
        let mut properties = HashMap::new();
        properties.insert("name".to_string(), serde_json::Value::String(name.to_string()));
        let transforms_array = transforms.iter().map(|s| serde_json::Value::String(s.clone())).collect();
        properties.insert("transforms".to_string(), serde_json::Value::Array(transforms_array));
        
        // Create default executable content
        let executable_content = format!(
            "#!/usr/bin/env python3\n\n# Tool: {}\n# Transforms: {:?}\n# Generated by Port 42\n\nimport sys\n\ndef main():\n    print(f\"Tool {name} processes: {{', '.join(sys.argv[1:])}}\")\n    # TODO: Implement actual tool logic\n    return 0\n\nif __name__ == '__main__':\n    sys.exit(main())\n",
            name, transforms
        );
        properties.insert("executable".to_string(), serde_json::Value::String(executable_content));
        
        Self {
            id: String::new(), // Will be set by server
            relation_type: "Tool".to_string(),
            properties,
            created_at: None, // Will be set by server
            updated_at: None, // Will be set by server
        }
    }
    
    pub fn new_artifact(name: &str, artifact_type: &str, file_type: &str) -> Self {
        let mut properties = HashMap::new();
        properties.insert("name".to_string(), serde_json::Value::String(name.to_string()));
        properties.insert("artifact_type".to_string(), serde_json::Value::String(artifact_type.to_string()));
        properties.insert("file_type".to_string(), serde_json::Value::String(file_type.to_string()));
        
        Self {
            id: String::new(),
            relation_type: "Artifact".to_string(),
            properties,
            created_at: None,
            updated_at: None,
        }
    }
}

impl Reference {
    // Parse from CLI string: "search:nginx errors" -> Reference
    pub fn from_string(input: &str) -> Result<Self> {
        if let Some((type_part, target_part)) = input.split_once(':') {
            Ok(Reference {
                ref_type: type_part.to_string(),
                target: target_part.to_string(),
                context: None,
            })
        } else {
            Err(anyhow::anyhow!("Invalid reference format. Use: type:target (e.g., search:\"nginx errors\", tool:log-parser)"))
        }
    }
}

// Protocol implementations
impl RequestBuilder for DeclareRelationRequest {
    fn build_request(&self, id: String) -> Result<DaemonRequest> {
        use crate::common::generate_session_id;
        use crate::protocol::SessionContext;
        
        // Step 5: Generate CLI session context for memory-relation bridge
        let session_context = Some(SessionContext {
            session_id: Some(generate_session_id()),
            agent: None, // CLI sessions don't have AI agent context
        });
        
        Ok(DaemonRequest {
            request_type: "declare_relation".to_string(),
            id,
            payload: serde_json::to_value(self)?,
            references: self.references.clone(),
            session_context,
            user_prompt: self.user_prompt.clone(),
        })
    }
}


// Response parsers
impl ResponseParser for DeclareRelationResponse {
    type Output = Self;
    fn parse_response(data: &serde_json::Value) -> Result<Self::Output> {
        Ok(serde_json::from_value(data.clone())?)
    }
}


// Display implementations
impl Displayable for DeclareRelationResponse {
    fn display(&self, format: OutputFormat) -> Result<()> {
        match format {
            OutputFormat::Json => {
                println!("{}", serde_json::to_string_pretty(self)?);
            }
            OutputFormat::Plain | OutputFormat::Table => {
                println!("{}", "âœ¨ Relation declared and materialized!".bright_green());
                println!("  {}: {}", "ID".bright_cyan(), self.relation_id);
                println!("  {}: {}", "Type".bright_cyan(), self.relation_type);
                println!("  {}: {}", "Status".bright_cyan(), self.status.bright_white());
                println!("  {}: {}", "Path".bright_cyan(), self.physical_path.bright_white());
                
                if self.relation_type == "Tool" {
                    println!("\n{}", "ðŸ”¨ Tool is ready to use!".bright_blue());
                    if let Some(name) = std::path::Path::new(&self.physical_path).file_name() {
                        println!("  Try: {}", name.to_string_lossy().bright_green());
                    }
                }
            }
        }
        Ok(())
    }
}


