use anyhow::{Context, Result};
use colored::*;
use std::fs;
use std::path::PathBuf;
use crate::protocol::{RealityData, CommandInfo};
use crate::display::{Displayable, OutputFormat};
use crate::help_text;

pub fn handle_reality(port: u16, verbose: bool, agent: Option<String>) -> Result<()> {
    handle_reality_with_format(port, verbose, agent, OutputFormat::Plain)
}

pub fn handle_reality_with_format(_port: u16, verbose: bool, agent: Option<String>, format: OutputFormat) -> Result<()> {
    if format != OutputFormat::Json {
        println!("{}", help_text::MSG_COMMANDS_HEADER.blue().bold());
        println!();
    }
    
    let commands_dir = dirs::home_dir()
        .context("Could not find home directory")?  
        .join(".port42")
        .join("commands");
    
    if !commands_dir.exists() {
        // No commands directory - display empty state
        let reality_data = RealityData {
            commands: vec![],
            total: 0,
            commands_dir,
        };
        
        return reality_data.display(format);
    }
    
    let mut commands = Vec::new();
    
    // Read all files in commands directory
    for entry in fs::read_dir(&commands_dir)? {
        let entry = entry?;
        let path = entry.path();
        
        if path.is_file() {
            if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                // Skip hidden files and backup files
                if !name.starts_with('.') && !name.ends_with('~') {
                    // Check if executable
                    #[cfg(unix)]
                    {
                        use std::os::unix::fs::PermissionsExt;
                        let metadata = fs::metadata(&path)?;
                        if metadata.permissions().mode() & 0o111 != 0 {
                            commands.push((name.to_string(), path));
                        }
                    }
                    
                    #[cfg(not(unix))]
                    {
                        commands.push((name.to_string(), path));
                    }
                }
            }
        }
    }
    
    // Sort by name
    commands.sort_by(|a, b| a.0.cmp(&b.0));
    
    // Convert to CommandInfo structures
    let mut command_infos = Vec::new();
    
    for (name, path) in commands {
        let (language, description, agent_name) = extract_metadata(&path)?;
        
        // Filter by agent if specified
        if let Some(ref agent_filter) = agent {
            if agent_name.as_deref() != Some(agent_filter) {
                continue;
            }
        }
        
        command_infos.push(CommandInfo {
            name,
            path,
            language,
            description,
            agent: agent_name,
        });
    }
    
    // Create structured data for display
    let reality_data = RealityData {
        total: command_infos.len(),
        commands: command_infos,
        commands_dir,
    };
    
    // Display using the framework
    let display_format = if format == OutputFormat::Json {
        OutputFormat::Json
    } else if verbose {
        OutputFormat::Table
    } else {
        OutputFormat::Plain
    };
    
    reality_data.display(display_format)?;
    
    Ok(())
}

fn extract_metadata(path: &PathBuf) -> Result<(String, Option<String>, Option<String>)> {
    let mut language = "unknown".to_string();
    let mut description = None;
    let mut agent = None;
    
    if let Ok(content) = fs::read_to_string(path) {
        // Detect language from shebang
        if let Some(first_line) = content.lines().next() {
            if first_line.starts_with("#!/") {
                if first_line.contains("python") {
                    language = "python".to_string();
                } else if first_line.contains("node") {
                    language = "node".to_string();
                } else if first_line.contains("bash") || first_line.contains("sh") {
                    language = "bash".to_string();
                }
            }
        }
        
        // Look for metadata in comments
        let mut found_generated_line = false;
        for (i, line) in content.lines().enumerate().take(10) {
            // Look for the "Generated by Port 42" line
            if line.contains("Generated by Port 42") {
                found_generated_line = true;
            }
            // The description is usually the line after "Generated by Port 42"
            else if found_generated_line && line.starts_with("#") {
                let desc_line = line.trim_start_matches('#').trim();
                if !desc_line.is_empty() {
                    description = Some(desc_line.to_string());
                    found_generated_line = false;
                }
            }
            
            // Look for agent in various formats
            if line.contains("Agent:") || line.contains("Created by:") {
                if let Some(agent_name) = line.split(':').nth(1) {
                    agent = Some(agent_name.trim().to_string());
                }
            } else if line.contains("@ai-") {
                // Extract agent from mentions like "@ai-engineer"
                if let Some(start) = line.find("@ai-") {
                    let agent_part = &line[start..];
                    if let Some(end) = agent_part.find(|c: char| !c.is_alphanumeric() && c != '-' && c != '@') {
                        agent = Some(agent_part[..end].to_string());
                    } else {
                        agent = Some(agent_part.to_string());
                    }
                }
            }
        }
    }
    
    Ok((language, description, agent))
}