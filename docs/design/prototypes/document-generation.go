package main

// Prototype for document generation in Port 42

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"strings"
	"time"
)

// DocumentSpec represents a document to be created
type DocumentSpec struct {
	Type        string                 `json:"type"`        // "decision", "strategy", "knowledge", "meeting"
	Title       string                 `json:"title"`
	Description string                 `json:"description"`
	Content     string                 `json:"content"`     // Markdown content
	Tags        []string               `json:"tags"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// DocumentArtifact represents a saved document
type DocumentArtifact struct {
	ID          string                 `json:"id"`
	Type        string                 `json:"type"`
	Title       string                 `json:"title"`
	Description string                 `json:"description"`
	Path        string                 `json:"path"`
	CreatedAt   time.Time              `json:"created_at"`
	UpdatedAt   time.Time              `json:"updated_at"`
	SessionID   string                 `json:"session_id"`
	Agent       string                 `json:"agent"`
	Tags        []string               `json:"tags"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// DocumentStore manages document artifacts
type DocumentStore struct {
	baseDir string
	index   []DocumentArtifact
}

// GenerateDocument creates a document from a specification
func (d *Daemon) generateDocument(spec *DocumentSpec, session *Session) error {
	log.Printf("ğŸ“„ Crystallizing document '%s'...", spec.Title)
	
	// Generate filename
	date := time.Now().Format("2006-01-02")
	slug := generateSlug(spec.Title)
	filename := fmt.Sprintf("%s-%s.md", date, slug)
	
	// Determine subdirectory based on type
	subdir := spec.Type
	if subdir == "" {
		subdir = "general"
	}
	
	// Create directory structure
	docDir := filepath.Join(d.baseDir, "artifacts", subdir)
	if err := os.MkdirAll(docDir, 0755); err != nil {
		return fmt.Errorf("failed to create document directory: %v", err)
	}
	
	// Add metadata header to content
	header := fmt.Sprintf(`---
title: %s
type: %s
created: %s
session: %s
agent: %s
tags: %s
---

# %s

%s

---

## Content

`, spec.Title, spec.Type, date, session.ID, session.Agent, 
		strings.Join(spec.Tags, ", "), spec.Title, spec.Description)
	
	fullContent := header + spec.Content + fmt.Sprintf("\n\n---\n*Generated by Port 42 with %s on %s*", 
		session.Agent, time.Now().Format("January 2, 2006"))
	
	// Write document
	docPath := filepath.Join(docDir, filename)
	if err := ioutil.WriteFile(docPath, []byte(fullContent), 0644); err != nil {
		return fmt.Errorf("failed to write document: %v", err)
	}
	
	// Update document index
	artifact := DocumentArtifact{
		ID:          fmt.Sprintf("doc-%d", time.Now().Unix()),
		Type:        spec.Type,
		Title:       spec.Title,
		Description: spec.Description,
		Path:        docPath,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
		SessionID:   session.ID,
		Agent:       session.Agent,
		Tags:        spec.Tags,
		Metadata:    spec.Metadata,
	}
	
	if err := d.documentStore.addArtifact(artifact); err != nil {
		return fmt.Errorf("failed to update document index: %v", err)
	}
	
	log.Printf("âœ… Document saved to %s", docPath)
	
	// Also create a quick access command
	cmdName := fmt.Sprintf("view-%s", slug)
	viewCmd := fmt.Sprintf(`#!/bin/bash
# View document: %s
# Generated by Port 42

DOC_PATH="%s"

if [ "$1" = "--edit" ]; then
    ${EDITOR:-vim} "$DOC_PATH"
else
    cat "$DOC_PATH" | ${PAGER:-less}
fi
`, spec.Title, docPath)
	
	cmdPath := filepath.Join(d.baseDir, "commands", cmdName)
	if err := ioutil.WriteFile(cmdPath, []byte(viewCmd), 0755); err != nil {
		log.Printf("Warning: failed to create view command: %v", err)
	}
	
	return nil
}

// Example prompts for different document types
var DocumentPrompts = map[string]string{
	"decision": `Create a decision document that captures:
- The decision that was made
- The context and constraints
- Options that were considered
- The rationale for the chosen approach
- Next steps and action items`,
	
	"strategy": `Create a strategy document that includes:
- Executive summary
- Current state analysis
- Goals and objectives
- Strategic initiatives
- Success metrics
- Timeline and milestones`,
	
	"knowledge": `Create a knowledge document that covers:
- Key concepts and definitions
- Important insights discovered
- Relevant examples or case studies
- Practical applications
- References and further reading`,
	
	"meeting": `Create a meeting notes document with:
- Attendees and date
- Agenda items discussed
- Key decisions made
- Action items with owners
- Follow-up items`,
}

// Helper to generate URL-safe slugs
func generateSlug(title string) string {
	slug := strings.ToLower(title)
	slug = strings.ReplaceAll(slug, " ", "-")
	slug = strings.ReplaceAll(slug, "/", "-")
	slug = strings.ReplaceAll(slug, "\\", "-")
	slug = strings.ReplaceAll(slug, ".", "-")
	slug = strings.ReplaceAll(slug, ",", "")
	slug = strings.ReplaceAll(slug, ":", "")
	slug = strings.ReplaceAll(slug, ";", "")
	slug = strings.ReplaceAll(slug, "?", "")
	slug = strings.ReplaceAll(slug, "!", "")
	slug = strings.ReplaceAll(slug, "'", "")
	slug = strings.ReplaceAll(slug, "\"", "")
	
	// Limit length
	if len(slug) > 50 {
		slug = slug[:50]
	}
	
	return slug
}