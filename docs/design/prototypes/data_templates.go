package main

// DataCommandTemplates provides templates for CRUD-based data management commands
var DataCommandTemplates = map[string]string{
	"simple-crud": `#!/bin/bash
# Generated by Port 42 - {{.Timestamp}}
# Data Management: {{.Name}}
# Description: {{.Description}}

set -e

DATA_FILE="$HOME/.port42/data/{{.DataFileName}}.json"
DATA_DIR="$(dirname "$DATA_FILE")"

# Ensure data directory exists
mkdir -p "$DATA_DIR"

# Initialize data file if it doesn't exist
if [ ! -f "$DATA_FILE" ]; then
    echo '{"entries": []}' > "$DATA_FILE"
fi

# Color codes
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

# Generate ID
generate_id() {
    echo "$(date +%s)$(shuf -i 100-999 -n 1)"
}

case "${1:-list}" in
    add|create)
        shift
        if [ -z "$1" ]; then
            echo -e "${RED}Error: Item description required${NC}"
            echo "Usage: {{.Name}} add <description>"
            exit 1
        fi
        
        ID=$(generate_id)
        ITEM=$(jq -n \
            --arg id "$ID" \
            --arg desc "$*" \
            --arg created "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '{{.ItemSchema}}')
        
        jq ".entries += [$ITEM]" "$DATA_FILE" > "$DATA_FILE.tmp" && mv "$DATA_FILE.tmp" "$DATA_FILE"
        echo -e "${GREEN}✓ Added item $ID${NC}"
        ;;
        
    list|ls)
        echo -e "${BLUE}{{.ListHeader}}${NC}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        jq -r '.entries[] | {{.ListFormat}}' "$DATA_FILE"
        COUNT=$(jq '.entries | length' "$DATA_FILE")
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo -e "Total: ${GREEN}$COUNT${NC} items"
        ;;
        
    update)
        shift
        ID="$1"
        shift
        if [ -z "$ID" ] || [ -z "$1" ]; then
            echo -e "${RED}Error: ID and new value required${NC}"
            echo "Usage: {{.Name}} update <id> <new-value>"
            exit 1
        fi
        
        jq "({{.UpdateQuery}}) {{.UpdateAction}}" "$DATA_FILE" > "$DATA_FILE.tmp" && \
            mv "$DATA_FILE.tmp" "$DATA_FILE"
        echo -e "${GREEN}✓ Updated item $ID${NC}"
        ;;
        
    delete|rm)
        shift
        ID="$1"
        if [ -z "$ID" ]; then
            echo -e "${RED}Error: ID required${NC}"
            echo "Usage: {{.Name}} delete <id>"
            exit 1
        fi
        
        jq ".entries = [.entries[] | select(.id != \"$ID\")]" "$DATA_FILE" > "$DATA_FILE.tmp" && \
            mv "$DATA_FILE.tmp" "$DATA_FILE"
        echo -e "${GREEN}✓ Deleted item $ID${NC}"
        ;;
        
    *)
        echo "Usage: {{.Name}} [add|list|update|delete] [args...]"
        echo ""
        echo "Commands:"
        echo "  add <description>    Add a new item"
        echo "  list                 List all items"  
        echo "  update <id> <value>  Update an item"
        echo "  delete <id>          Delete an item"
        ;;
esac
`,

	"python-crud": `#!/usr/bin/env python3
# Generated by Port 42 - {{.Timestamp}}
# Data Management: {{.Name}}
# Description: {{.Description}}

import json
import os
import sys
import argparse
from datetime import datetime
from pathlib import Path

class DataManager:
    def __init__(self):
        self.data_file = Path.home() / '.port42' / 'data' / '{{.DataFileName}}.json'
        self.data_file.parent.mkdir(parents=True, exist_ok=True)
        self.load_data()
    
    def load_data(self):
        if self.data_file.exists():
            with open(self.data_file, 'r') as f:
                self.data = json.load(f)
        else:
            self.data = {"entries": []}
            self.save_data()
    
    def save_data(self):
        with open(self.data_file, 'w') as f:
            json.dump(self.data, f, indent=2)
    
    def generate_id(self):
        import random
        return f"{int(datetime.now().timestamp())}{random.randint(100, 999)}"
    
    def add(self, {{.AddParams}}):
        entry = {
            "id": self.generate_id(),
            {{.EntryFields}},
            "created": datetime.utcnow().isoformat() + "Z",
            "updated": datetime.utcnow().isoformat() + "Z"
        }
        self.data["entries"].append(entry)
        self.save_data()
        print(f"✓ Added item {entry['id']}")
        return entry["id"]
    
    def list_items(self, {{.ListParams}}):
        entries = self.data["entries"]
        {{.FilterLogic}}
        
        print(f"{{.ListHeader}}")
        print("=" * 50)
        for entry in entries:
            {{.DisplayLogic}}
        print("=" * 50)
        print(f"Total: {len(entries)} items")
    
    def update(self, item_id, {{.UpdateParams}}):
        for entry in self.data["entries"]:
            if entry["id"] == item_id:
                {{.UpdateLogic}}
                entry["updated"] = datetime.utcnow().isoformat() + "Z"
                self.save_data()
                print(f"✓ Updated item {item_id}")
                return True
        print(f"✗ Item {item_id} not found")
        return False
    
    def delete(self, item_id):
        original_count = len(self.data["entries"])
        self.data["entries"] = [e for e in self.data["entries"] if e["id"] != item_id]
        if len(self.data["entries"]) < original_count:
            self.save_data()
            print(f"✓ Deleted item {item_id}")
            return True
        print(f"✗ Item {item_id} not found")
        return False

def main():
    parser = argparse.ArgumentParser(description='{{.Description}}')
    subparsers = parser.add_subparsers(dest='command', help='Commands')
    
    # Add command
    add_parser = subparsers.add_parser('add', help='Add a new item')
    {{.AddArgparse}}
    
    # List command
    list_parser = subparsers.add_parser('list', help='List items')
    {{.ListArgparse}}
    
    # Update command
    update_parser = subparsers.add_parser('update', help='Update an item')
    update_parser.add_argument('id', help='Item ID')
    {{.UpdateArgparse}}
    
    # Delete command
    delete_parser = subparsers.add_parser('delete', help='Delete an item')
    delete_parser.add_argument('id', help='Item ID')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    dm = DataManager()
    
    if args.command == 'add':
        {{.AddCall}}
    elif args.command == 'list':
        {{.ListCall}}
    elif args.command == 'update':
        {{.UpdateCall}}
    elif args.command == 'delete':
        dm.delete(args.id)

if __name__ == '__main__':
    main()
`,
}

// DataTemplateExamples provides examples for the AI
var DataTemplateExamples = map[string]DataCommandSpec{
	"task-tracker": {
		Name:        "task-tracker",
		Description: "Track tasks and TODOs",
		Schema: DataSchema{
			Fields: []DataField{
				{Name: "description", Type: "string", Required: true},
				{Name: "status", Type: "string", Default: "pending"},
				{Name: "priority", Type: "string", Default: "medium"},
				{Name: "due_date", Type: "string", Required: false},
			},
		},
		Operations: []string{"add", "list", "update", "delete", "complete"},
	},
	"idea-journal": {
		Name:        "idea-journal",
		Description: "Capture and organize ideas",
		Schema: DataSchema{
			Fields: []DataField{
				{Name: "title", Type: "string", Required: true},
				{Name: "description", Type: "string", Required: true},
				{Name: "category", Type: "string", Default: "general"},
				{Name: "tags", Type: "array", Required: false},
			},
		},
		Operations: []string{"add", "list", "search", "update", "delete"},
	},
}

// DataCommandSpec defines a data management command
type DataCommandSpec struct {
	Name        string     `json:"name"`
	Description string     `json:"description"`
	Schema      DataSchema `json:"schema"`
	Operations  []string   `json:"operations"`
	Language    string     `json:"language"` // bash or python
}

// DataSchema defines the structure of data
type DataSchema struct {
	Fields []DataField `json:"fields"`
}

// DataField defines a single field in the schema
type DataField struct {
	Name     string      `json:"name"`
	Type     string      `json:"type"` // string, number, boolean, array
	Required bool        `json:"required"`
	Default  interface{} `json:"default,omitempty"`
}