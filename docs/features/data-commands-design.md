# Data Commands Design - Living Documents

**Purpose**: Design specification for data commands - the third type of crystallization
**Scope**: How data commands work, implementation approach, use cases

## Overview

Data commands are Port 42's approach to "living documents" - structured data that evolves through conversation. They're essentially JSON spreadsheets with a CLI interface, generated uniquely for each user's needs.

## Core Concept

A data command is:
- A generated bash script that manages structured data
- Stores data as JSON in `~/.port42/data/{command-name}.json`
- Provides CRUD operations (Create, Read, Update, Delete)
- Schema discovered through conversation, not predefined
- Simple implementation using bash + jq

## Use Case: Content Calendar

### 1. Discovery Phase

```bash
possess @ai-growth "I need to track our blog content calendar"
```

The AI explores requirements through conversation:
- What fields are needed (title, status, author, etc.)
- What statuses make sense (draft, review, published)
- What metrics to track (views, shares)
- Any special requirements (URLs, tags, deadlines)

### 2. Generation Phase

```bash
> /crystallize data
```

The AI generates a command based on the discovered schema:

```json
{
  "name": "content-calendar",
  "description": "Manage blog content calendar with posts, status, and metrics",
  "schema": {
    "title": {"type": "string", "required": true},
    "status": {"type": "enum", "values": ["draft", "review", "published"], "default": "draft"},
    "author": {"type": "string"},
    "publish_date": {"type": "date"},
    "topics": {"type": "array"},
    "views": {"type": "number", "default": 0},
    "shares": {"type": "number", "default": 0},
    "draft_url": {"type": "string"},
    "published_url": {"type": "string"}
  },
  "list_columns": ["id", "title", "status", "publish_date", "views"],
  "search_fields": ["title", "author", "topics"]
}
```

### 3. Usage Phase

The generated command provides intuitive CRUD operations:

```bash
# Add a new post
content-calendar add "How Port 42 Changes Everything" \
  --author "Gordon" \
  --status draft \
  --topics "ai,developer-tools"

# List all posts
content-calendar list
# Output:
# ID  Title                            Status  Publish Date  Views
# 1   How Port 42 Changes Everything   draft   -            0

# Update when published
content-calendar update 1 \
  --status published \
  --publish_date "2024-01-20" \
  --published_url "https://blog.port42.dev/post"

# Track metrics
content-calendar update 1 --views 1250 --shares 45

# Search posts
content-calendar search "ai"

# Show detailed view
content-calendar show 1
```

## Implementation Details

### Generated Command Structure

```bash
#!/bin/bash
# Auto-generated by Port 42 Data Command Generator
# Schema: content-calendar

DATA_FILE="$HOME/.port42/data/content-calendar.json"
LOCK_FILE="$DATA_FILE.lock"

# Ensure data directory exists
mkdir -p "$(dirname "$DATA_FILE")"

# Initialize data file if it doesn't exist
if [ ! -f "$DATA_FILE" ]; then
    echo '[]' > "$DATA_FILE"
fi

# Lock file handling for concurrent access
acquire_lock() {
    local timeout=5
    local elapsed=0
    while [ -f "$LOCK_FILE" ] && [ $elapsed -lt $timeout ]; do
        sleep 0.1
        elapsed=$((elapsed + 1))
    done
    touch "$LOCK_FILE"
}

release_lock() {
    rm -f "$LOCK_FILE"
}

# CRUD operations implementation
case "$1" in
    add)
        # Parse arguments
        # Generate ID
        # Add timestamp
        # Append to JSON array
        ;;
    list)
        # Format output with jq
        # Column alignment
        # Pagination for large datasets
        ;;
    show)
        # Display single item with all fields
        ;;
    update)
        # Find by ID
        # Update specified fields
        # Maintain history if needed
        ;;
    delete)
        # Remove by ID
        # Optional: soft delete
        ;;
    search)
        # Search across specified fields
        # Basic text matching
        ;;
    export)
        # Export to CSV/JSON
        ;;
    *)
        echo "Usage: content-calendar {add|list|show|update|delete|search|export}"
        ;;
esac
```

### Data Storage Format

```json
[
  {
    "id": 1,
    "title": "How Port 42 Changes Everything",
    "status": "published",
    "author": "Gordon",
    "publish_date": "2024-01-20",
    "topics": ["ai", "developer-tools"],
    "views": 1250,
    "shares": 45,
    "draft_url": null,
    "published_url": "https://blog.port42.dev/post",
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-20T14:22:00Z"
  }
]
```

## Key Features

### 1. Schema Discovery
- Schema emerges from conversation
- No predefined structures
- Flexible field types: string, number, date, enum, array, boolean

### 2. Smart Defaults
- Auto-generated IDs
- Timestamps (created_at, updated_at)
- Default values for fields
- Enum validation

### 3. User-Friendly Output
- Formatted tables for list view
- Column selection for different views
- JSON export for integration
- CSV export for spreadsheets

### 4. Basic Search
- Text search across specified fields
- Filter by field values
- Date range queries

## Minimal MVP Implementation

For the first version, we focus on:

1. **Simple schema definition** - Just field names and types
2. **Basic CRUD** - Add, list, show, update, delete
3. **Text search** - Simple grep-like search
4. **JSON storage** - Single file per command
5. **Bash + jq** - No external dependencies

What we're NOT doing (yet):
- Relationships between data types
- Schema migrations
- Complex queries
- Validation beyond basic types
- Real-time sync
- Multi-user access

## Tool Definition for AI

```go
func getDataGenerationTool() AnthropicTool {
    return AnthropicTool{
        Name:        "generate_data",
        Description: "Generate a data management command with CRUD operations",
        InputSchema: map[string]interface{}{
            "type": "object",
            "properties": map[string]interface{}{
                "name": map[string]interface{}{
                    "type":        "string",
                    "description": "Command name (e.g., content-calendar, feature-tracker)",
                },
                "description": map[string]interface{}{
                    "type":        "string",
                    "description": "What this data command manages",
                },
                "schema": map[string]interface{}{
                    "type":        "object",
                    "description": "Field definitions with types and constraints",
                    "additionalProperties": map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                            "type":     map[string]interface{}{"type": "string", "enum": []string{"string", "number", "boolean", "date", "array", "enum"}},
                            "required": map[string]interface{}{"type": "boolean"},
                            "default":  map[string]interface{}{"type": ["string", "number", "boolean", "null"]},
                            "values":   map[string]interface{}{"type": "array", "items": map[string]interface{}{"type": "string"}},
                        },
                    },
                },
                "list_columns": map[string]interface{}{
                    "type":        "array",
                    "description": "Fields to show in list view",
                    "items":       map[string]interface{}{"type": "string"},
                },
                "search_fields": map[string]interface{}{
                    "type":        "array",
                    "description": "Fields to search across",
                    "items":       map[string]interface{}{"type": "string"},
                },
            },
            "required": []string{"name", "description", "schema"},
        },
    }
}
```

## Benefits

1. **Zero Configuration** - Schema discovered through conversation
2. **Instant Value** - Working CRUD command in seconds
3. **Portable** - Just JSON files, easy to backup/share
4. **Extensible** - Can regenerate with new fields anytime
5. **No Lock-in** - Data is just JSON, can export anytime

## Future Enhancements

Once the MVP is working, we could add:

1. **Schema Evolution** - Migrate data when schema changes
2. **Relationships** - Link between different data types
3. **Views** - Custom queries and reports
4. **Sync** - Real-time collaboration
5. **Validation** - More complex field constraints
6. **Webhooks** - Trigger actions on data changes

## Summary

Data commands turn conversations into structured data tools. They're:
- Generated uniquely for each use case
- Simple JSON storage with bash interface
- Schema discovered through dialogue
- Living documents that evolve with needs

This gives users the power to create custom data management tools without any coding, just by describing what they need to track.