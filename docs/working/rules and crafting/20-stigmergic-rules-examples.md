# 20 Stigmergic Intelligence Rules for Port 42 Reality Compiler

*Emergent patterns that make terminals increasingly intelligent through use*

## Pattern Detection Rules (Stigmergic Intelligence)

### 1. **Show-All Aggregator Rule** *(Proven from prototype)*
```
Pattern: 3+ commands with "show" prefix
Trigger: show-git-status, show-pwd, show-processes
Spawns: show-all (meta-command that runs all show-* commands)
Example: $ show-all → runs all user's show commands in sequence
```

### 2. **Git Workflow Completer Rule**
```
Pattern: User has git-status + git-add + git-commit tools  
Trigger: Detection of git trio
Spawns: git-flow (automated add→commit→push workflow)
Intelligence: Learns user's git habits and creates shortcuts
```

### 3. **Config Manager Emergence Rule**
```
Pattern: 4+ commands editing different config files (.vimrc, .bashrc, etc.)
Trigger: edit-vimrc, edit-bashrc, edit-gitconfig, edit-profile
Spawns: config-manager (unified config editing interface)
Behavior: Creates ~/.port42-configs/ backup system
```

### 4. **Dev Environment Detector Rule**  
```
Pattern: Language-specific tools clustering (3+ tools with same language)
Trigger: python-lint, python-test, python-format  
Spawns: python-dev-env (integrated development environment command)
Intelligence: Auto-detects project structure and creates environment
```

### 5. **Log Analysis Convergence Rule**
```
Pattern: Multiple log reading tools (nginx-logs, error-logs, access-logs)
Trigger: 3+ different log analysis commands
Spawns: unified-logs (smart log aggregator and analyzer)
Features: Correlates timestamps, highlights errors across logs
```

### 6. **Monitoring Dashboard Rule**
```
Pattern: System monitoring commands (cpu-usage, memory-check, disk-space)
Trigger: Collection of system metrics tools
Spawns: system-dashboard (real-time monitoring interface)
Behavior: Creates TUI dashboard with all monitored metrics
```

### 7. **Backup Strategy Emergence Rule**
```
Pattern: User creates backup commands for different directories  
Trigger: backup-code, backup-docs, backup-configs (3+ backup tools)
Spawns: backup-all (intelligent backup orchestrator)
Intelligence: Learns backup frequencies, creates schedules
```

### 8. **Network Tool Constellation Rule**
```
Pattern: Network diagnostic tools clustering
Trigger: ping-check, port-scan, network-test, dns-lookup
Spawns: network-doctor (comprehensive network diagnostics)
Features: Automated troubleshooting workflows
```

### 9. **Database Administration Rule**
```
Pattern: Database management commands appearing
Trigger: db-backup, db-migrate, db-query, db-optimize
Spawns: db-admin (unified database management interface)
Intelligence: Detects database type, creates appropriate admin tools
```

### 10. **File Organization Intelligence Rule**
```
Pattern: File management commands with similar patterns
Trigger: organize-downloads, organize-photos, organize-documents  
Spawns: smart-organizer (AI-powered file organization system)
Behavior: Learns user's organization preferences
```

## Temporal Pattern Rules

### 11. **Daily Ritual Detector Rule**
```
Pattern: Commands run consistently at similar times
Trigger: Same commands executed 5+ days in same time window
Spawns: morning-routine / evening-routine automated sequences
Intelligence: Creates time-based automated workflows
```

### 12. **Project Lifecycle Rule**
```
Pattern: Commands that appear together in sequence frequently
Trigger: project-init → setup-env → create-readme → git-init sequence
Spawns: new-project (complete project initialization template)
Learning: Adapts to user's specific project setup patterns
```

### 13. **Deployment Pipeline Rule**
```
Pattern: Deployment-related commands used together
Trigger: build-app, run-tests, deploy-staging, deploy-prod sequence
Spawns: deploy-pipeline (automated CI/CD workflow)
Intelligence: Learns deployment dependencies and safety checks
```

## Context-Aware Rules

### 14. **Working Directory Intelligence Rule**
```
Pattern: Commands that work on current directory files/structure
Trigger: Directory-specific tools in multiple directories  
Spawns: Contextual quick-commands based on directory contents
Example: In Node.js project → spawns npm-dev, npm-build automatically
```

### 15. **Language-Specific Toolchain Rule**
```  
Pattern: Tools for specific programming language accumulating
Trigger: rust-build, rust-test, rust-fmt, cargo-check (Rust example)
Spawns: rust-dev (integrated Rust development environment)
Behavior: Creates language-specific development shortcuts
```

### 16. **Security Audit Constellation Rule**
```
Pattern: Security-related tools clustering
Trigger: check-permissions, scan-vulnerabilities, audit-packages
Spawns: security-audit (comprehensive security analysis)
Intelligence: Creates security checklists based on user's tools
```

## Collaborative Intelligence Rules

### 17. **Team Workflow Detector Rule**
```
Pattern: Communication and collaboration tools  
Trigger: slack-status, git-team-status, meeting-notes
Spawns: team-sync (integrated team collaboration dashboard)
Features: Correlates team activities with development work
```

### 18. **Documentation Emergence Rule**
```
Pattern: Documentation-related commands appearing
Trigger: write-readme, generate-docs, update-changelog
Spawns: doc-manager (intelligent documentation system)  
Intelligence: Auto-generates documentation templates from code
```

## Adaptive Learning Rules

### 19. **Error Recovery Pattern Rule**
```
Pattern: Commands that fix common errors user encounters
Trigger: fix-permissions, restart-service, clear-cache (error-fixing tools)
Spawns: auto-doctor (automated error detection and fixing)
Learning: Learns user's common problems and solutions
```

### 20. **Efficiency Optimization Rule**
```
Pattern: Commands that could be optimized or combined
Trigger: Analysis of command usage frequency and sequences
Spawns: optimized-workflows (suggestions for command combinations)
Intelligence: Continuously learns user patterns to suggest improvements
```

## Implementation Philosophy

These rules embody **stigmergic intelligence** - the system becomes smarter through use:

1. **Pattern Recognition**: System detects emergent patterns in user behavior
2. **Intelligent Spawning**: Creates meta-commands that anticipate user needs  
3. **Adaptive Learning**: Rules evolve based on actual usage patterns
4. **Contextual Awareness**: Commands spawned are relevant to user's environment
5. **Temporal Intelligence**: System learns time-based patterns and workflows

## Rule Interaction Effects

- **Cascade Effects**: Rules can trigger other rules (show-all + git-flow → creates dev-workflow)
- **Context Sensitivity**: Same patterns in different contexts spawn different tools
- **User Personalization**: Each user's terminal becomes uniquely intelligent
- **Emergent Complexity**: Simple rules combine to create sophisticated behaviors

## The Magic Outcome

The user never explicitly programs rules. Instead:
- They use their terminal naturally
- The system detects patterns in their behavior  
- Commands automatically appear that anticipate their needs
- Terminal becomes increasingly personalized and intelligent
- Each user develops their own unique "digital environment"

This creates a **self-organizing, evolving terminal** that grows smarter with use - the essence of premise-driven stigmergic intelligence.